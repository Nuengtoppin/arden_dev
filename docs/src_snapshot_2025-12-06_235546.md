## app\mod.rs

```rust
// src/app/mod.rs

pub mod plugins;
pub mod setup;
```

## app\plugins.rs

```rust
// src/app/plugins.rs
use bevy::prelude::*;

/// Общий плагин Arden/Arden Engine для будущих расширений:
/// сюда позже добавим egui, inspector, Rapier и т.п.
pub struct CorePlugins;

impl Plugin for CorePlugins {
    fn build(&self, _app: &mut App) {
        // Пока ничего не добавляем.
        // На следующих фазах здесь будут регистрироваться дополнительные плагины.
    }
}
```

## app\setup.rs

```rust
// src/app/setup.rs
use bevy::prelude::*;
use bevy_rapier3d::prelude::*;
use crate::physics::collider_builder::collider_from_mesh;
use crate::tools::camera_controller::FlyCamera;


pub fn setup_camera_and_light(mut commands: Commands) {
    // Камера оставляем как есть
    let camera_transform = Transform::from_xyz(-80.0, 80.0, 120.0)
        .looking_at(Vec3::ZERO, Vec3::Y);

    commands.spawn((
        Camera3dBundle {
            transform: camera_transform,
            ..default()
        },
        FlyCamera::from_transform(&camera_transform),
    ));

    // 1) Основной "солнечный" свет (key light)
    commands.spawn(DirectionalLightBundle {
        directional_light: DirectionalLight {
            color: Color::rgb(1.0, 0.97, 0.92),
            illuminance: 20_000.0,
            shadows_enabled: true,
            ..default()
        },
        transform: Transform::from_xyz(180.0, 160.0, 180.0)
            .looking_at(Vec3::ZERO, Vec3::Y),
        ..default()
    });

    // 2) Заполняющий свет с обратной стороны, без теней (fill light)
    commands.spawn(DirectionalLightBundle {
        directional_light: DirectionalLight {
            color: Color::rgb(0.8, 0.85, 0.9),
            illuminance: 4_000.0, // заметно слабее
            shadows_enabled: false,
            ..default()
        },
        transform: Transform::from_xyz(-180.0, 40.0, -180.0)
            .looking_at(Vec3::ZERO, Vec3::Y),
        ..default()
    });

    commands.spawn(DirectionalLightBundle {
        directional_light: DirectionalLight {
            color: Color::rgb(0.8, 0.85, 0.9),
            illuminance: 4_000.0, // заметно слабее
            shadows_enabled: false,
            ..default()
        },
        transform: Transform::from_xyz(-180.0, -40.0, -180.0)
            .looking_at(Vec3::ZERO, Vec3::Y),
        ..default()
    });

    commands.spawn(DirectionalLightBundle {
        directional_light: DirectionalLight {
            color: Color::rgb(0.8, 0.85, 0.9),
            illuminance: 10_000.0, // заметно слабее
            shadows_enabled: false,
            ..default()
        },
        transform: Transform::from_xyz(180.0, -160.0, 180.0)
            .looking_at(Vec3::ZERO, Vec3::Y),
        ..default()
    });

    // 3) Общий ambient, можно чуть приглушить, чтобы fill-свет работал
    commands.insert_resource(AmbientLight {
        color: Color::rgb(0.6, 0.6, 0.7),
        brightness: 1.3,
    });
}


/// Пол 512x512 + невидимые стены-борта высотой 512.
/// Верх аквариума открыт.
pub fn spawn_aquarium(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    let plane_size = 512.0;
    let wall_height = 512.0;
    let wall_thickness = 1.0;

    // --- Пол ---
    let floor_mesh = Mesh::from(shape::Plane::from_size(plane_size));
    let floor_collider = collider_from_mesh(&floor_mesh);
    let floor_mesh_handle = meshes.add(floor_mesh);

    let floor_material = materials.add(StandardMaterial {
        base_color: Color::rgb(0.12, 0.18, 0.12),
        perceptual_roughness: 1.0,
        metallic: 0.0,
        ..default()
    });

    commands.spawn((
        PbrBundle {
            mesh: floor_mesh_handle,
            material: floor_material,
            transform: Transform::from_xyz(0.0, 0.0, 0.0),
            ..default()
        },
        RigidBody::Fixed,
        floor_collider,
    ));

    // --- Стены (ТОЛЬКО КОЛЛАЙДЕРЫ, без видимого меша) ---
    let half_thickness = wall_thickness * 0.5;
    let half_height = wall_height * 0.5;
    let half_size = plane_size * 0.5;

    // Стены вдоль оси X (поставлены по краям по Z)
    let wall_x_collider = Collider::cuboid(half_thickness, half_height, half_size);

    // +X
    commands.spawn((
        TransformBundle::from(Transform::from_xyz(
            half_size + half_thickness,
            half_height,
            0.0,
        )),
        RigidBody::Fixed,
        wall_x_collider.clone(),
    ));

    // -X
    commands.spawn((
        TransformBundle::from(Transform::from_xyz(
            -half_size - half_thickness,
            half_height,
            0.0,
        )),
        RigidBody::Fixed,
        wall_x_collider,
    ));

    // Стены вдоль оси Z
    let wall_z_collider = Collider::cuboid(half_size, half_height, half_thickness);

    // +Z
    commands.spawn((
        TransformBundle::from(Transform::from_xyz(
            0.0,
            half_height,
            half_size + half_thickness,
        )),
        RigidBody::Fixed,
        wall_z_collider.clone(),
    ));

    // -Z
    commands.spawn((
        TransformBundle::from(Transform::from_xyz(
            0.0,
            half_height,
            -half_size - half_thickness,
        )),
        RigidBody::Fixed,
        wall_z_collider,
    ));
        // --- Потолок (невидимый, чисто коллайдер) ---
    let ceiling_thickness = 1.0;
    let half_ceiling_thickness = ceiling_thickness * 0.5;

    // Центр потолка: на высоте верхнего края стен
    let ceiling_y = wall_height + half_ceiling_thickness;

    let ceiling_collider = Collider::cuboid(
        half_size,              // по X половина размера пола
        half_ceiling_thickness, // толщина по Y
        half_size,              // по Z половина размера пола
    );

    commands.spawn((
        TransformBundle::from(Transform::from_xyz(0.0, ceiling_y, 0.0)),
        RigidBody::Fixed,
        ceiling_collider,
    ));

}
```

## dun\dun.rs

```rust
// src/dun/dun.rs
use bevy::prelude::*;

use crate::dun::kind::DunKind;
use crate::voxel::grid::VoxelGrid;

/// Базовый компонент DUN для MVP0.
/// Хранит только то, что реально нужно сейчас.
#[derive(Component)]
pub struct Dun {
    /// Тип DUN (для будущего различения Dynamic / Static и т.п.).
    pub kind: DunKind,
    /// Логическая координата чанка, к которому привязан DUN.
    pub chunk_coord: IVec3,
    /// Локальная воксельная решётка внутри контейнера.
    pub voxel: VoxelGrid,
}
```

## dun\kind.rs

```rust
// src/dun/kind.rs
use bevy::prelude::*;

/// Типы DUN для MVP0.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum DunKind {
    /// Динамический воксельный контейнер (наш текущий куб).
    DynamicVoxel,
}
```

## dun\mod.rs

```rust
// src/dun/mod.rs

pub mod dun;
pub mod kind;
//pub mod route_lite;
pub mod spawn;
//pub mod transform;
```

## dun\route_lite.rs

```rust
```

## dun\spawn.rs

```rust
// src/dun/spawn.rs
use bevy::prelude::*;
use bevy_rapier3d::prelude::*;

use crate::voxel::grid::VoxelGrid;
use crate::voxel::mesher::VOXEL_SIZE;
use crate::render::mesh_builder::build_bevy_mesh;

use crate::physics::collider_builder::{
    collider_from_mesh,
    collider_from_voxel_grid_box,
};

use crate::dun::dun::Dun;
use crate::dun::kind::DunKind;

/// Строим VoxelGrid 32×32×32 с шаром по центру.
/// Это и есть "наполнение" DUN для MVP.
fn build_dun_sphere_grid() -> VoxelGrid {
    // 32³ по умолчанию
    let mut grid = VoxelGrid::new_default();
    let size = grid.size;

    // Центр в воксельных координатах (по центрам ячеек)
    let cx = size.x as f32 / 2.0;
    let cy = size.y as f32 / 2.0;
    let cz = size.z as f32 / 2.0;

    // Радиус — чуть меньше половины по минимальной оси,
    // чтобы шар не упирался в край
    let r = (size.x.min(size.y).min(size.z) as f32 * 0.5) - 1.0;
    let r2 = r * r;

    for x in 0..size.x {
        for y in 0..size.y {
            for z in 0..size.z {
                let vx = x as f32 + 0.5;
                let vy = y as f32 + 0.5;
                let vz = z as f32 + 0.5;

                let dx = vx - cx;
                let dy = vy - cy;
                let dz = vz - cz;

                let dist2 = dx * dx + dy * dy + dz * dz;

                if dist2 <= r2 {
                    grid.set(x, y, z, 1);
                }
            }
        }
    }

    grid
}

/// Спавн одного DUN (контейнер 32³ с шаром внутри) с ЗАДАННЫМ трансформом.
/// transform трактуем как центр контейнера DUN в мировых координатах.
pub fn spawn_single_dun(
    commands: &mut Commands,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<StandardMaterial>>,
    transform: Transform,
) {
    // 1. Грид 32×32×32 с voxel-шаром
    let grid = build_dun_sphere_grid();

    // 2. Mesh из грида (он уже центрирован вокруг (0,0,0))
    let mesh = build_bevy_mesh(&grid);

    // 3. ПРОСТОЙ коллайдер по размеру контейнера DUN,
    //    а не по каждому треугольнику меша:
    let collider = collider_from_voxel_grid_box(&grid);

    // 4. Кладём меш в ресурсы
    let mesh_handle = meshes.add(mesh);

    // 5. Материал
    let material_handle = materials.add(StandardMaterial {
        base_color: Color::rgb(0.3, 0.6, 1.0),
        perceptual_roughness: 0.8,
        metallic: 0.0,
        double_sided: true,
        cull_mode: None,
        ..default()
    });

    // 6. Спавн сущности DUN
    commands.spawn((
        PbrBundle {
            mesh: mesh_handle,
            material: material_handle,
            transform,
            ..default()
        },
        RigidBody::Dynamic,
        collider,
        Dun {
            kind: DunKind::DynamicVoxel,
            chunk_coord: IVec3::ZERO,
            voxel: grid,
        },
    ));
}
```

## dun\transform.rs

```rust
```

## main.rs

```rust
// src/main.rs
use bevy::prelude::*;
use bevy_rapier3d::prelude::*;

mod app;
mod mvp0;
mod tools;
mod voxel;
mod render;
mod physics;
mod dun;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        // Физика
        .add_plugins(RapierPhysicsPlugin::<NoUserData>::default())
        // Визуализация коллайдеров (можно закомментировать при желании)
        .add_plugins(RapierDebugRenderPlugin::default())
        // Наша сцена MVP0
        .add_plugins(mvp0::scene::Mvp0ScenePlugin)
        .run();
}
```

## mvp0\mod.rs

```rust
// src/mvp0/mod.rs
pub mod scene;
pub mod stress_test;
```

## mvp0\scene.rs

```rust
// src/mvp0/scene.rs
use bevy::prelude::*;
use bevy::input::ButtonInput;
use bevy::input::keyboard::KeyCode;

use crate::app::setup::{setup_camera_and_light, spawn_aquarium};
use crate::tools::debug_grid::debug_grid_system;
use crate::tools::camera_controller::{fly_camera_look, fly_camera_move};
use crate::dun::spawn::spawn_single_dun;

pub struct Mvp0ScenePlugin;

impl Plugin for Mvp0ScenePlugin {
    fn build(&self, app: &mut App) {
        app
            // Один раз: камера + свет + аквариум
            .add_systems(Startup, (setup_camera_and_light, spawn_aquarium))
            // Каждый кадр: сетка, управление камерой, спавн DUN по E
            .add_systems(
                Update,
                (
                    debug_grid_system,
                    fly_camera_look,
                    fly_camera_move,
                    spawn_dun_on_e,
                ),
            );
    }
}

/// Временная система для MVP0:
/// по нажатию E спавним один DUN в направлении камеры,
/// с привязкой к сетке (шаг 16 world units).
fn spawn_dun_on_e(
    keyboard: Res<ButtonInput<KeyCode>>,
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    camera_q: Query<&Transform, With<Camera3d>>,
) {
    if !keyboard.just_pressed(KeyCode::KeyE) {
        return;
    }

    // Берём единственную 3D-камеру
    let Ok(cam_transform) = camera_q.get_single() else {
        return;
    };

    // Вектор взгляда камеры.
    // В Bevy по умолчанию камера смотрит вдоль -Z,
    // поэтому forward = rotation * (-Z).
    let forward = cam_transform.rotation * -Vec3::Z;

    // На каком расстоянии от камеры спавнить DUN (в мире, не в вокселях).
    // 32.0 ≈ "два контейнера вперёд" при VOXEL_SIZE=1.0 и size=32.
    let spawn_distance = 32.0;

    let raw_pos = cam_transform.translation + forward.normalize() * spawn_distance;

    // Привязка к сетке. Можно поменять шаг на 32.0, если хочешь
    // сразу снаппить по размеру контейнера DUN.
    let grid_step = 16.0;

    let snapped = Vec3::new(
        (raw_pos.x / grid_step).round() * grid_step,
        (raw_pos.y / grid_step).round() * grid_step,
        (raw_pos.z / grid_step).round() * grid_step,
    );

    let spawn_transform = Transform::from_translation(snapped);

    // Вызываем конструктор DUN: он сам строит шар и коллайдер по мешу.
    spawn_single_dun(
        &mut commands,
        &mut meshes,
        &mut materials,
        spawn_transform,
    );
}
```

## mvp0\stress_test.rs

```rust
// src/mvp0/stress_test.rs
// Стресс-тест будет реализован на более поздних фазах (MVP0.1 / 0.2).
```

## physics\collider_builder.rs

```rust
// src/physics/collider_builder.rs
use bevy::prelude::*;
use bevy::render::mesh::{Indices, VertexAttributeValues};
use bevy_rapier3d::prelude::*;

use crate::voxel::grid::VoxelGrid;
use crate::voxel::mesher::VOXEL_SIZE;

pub fn collider_from_mesh(mesh: &Mesh) -> Collider {
    let positions: Vec<Vec3> = match mesh.attribute(Mesh::ATTRIBUTE_POSITION) {
        Some(VertexAttributeValues::Float32x3(verts)) => verts
            .iter()
            .map(|[x, y, z]| Vec3::new(*x, *y, *z))
            .collect(),
        _ => {
            return Collider::cuboid(0.5, 0.5, 0.5);
        }
    };

    let raw_indices: Vec<u32> = match mesh.indices() {
        Some(Indices::U32(ind)) => ind.clone(),
        Some(Indices::U16(ind)) => ind.iter().map(|&i| i as u32).collect(),
        None => (0..positions.len() as u32).collect(),
    };

    let mut indices_triangles = Vec::new();
    for chunk in raw_indices.chunks(3) {
        if let [a, b, c] = chunk {
            indices_triangles.push([*a, *b, *c]);
        }
    }

    if positions.is_empty() || indices_triangles.is_empty() {
        Collider::cuboid(0.5, 0.5, 0.5)
    } else {
        Collider::trimesh(positions, indices_triangles)
    }
}

/// Коробка по размерам воксельной решётки.
pub fn collider_from_voxel_grid_box(grid: &VoxelGrid) -> Collider {
    let size = grid.size;

    let hx = size.x as f32 * VOXEL_SIZE * 0.5;
    let hy = size.y as f32 * VOXEL_SIZE * 0.5;
    let hz = size.z as f32 * VOXEL_SIZE * 0.5;

    Collider::cuboid(hx, hy, hz)
}
```

## physics\mod.rs

```rust
//src/physics/mod.rs
pub mod collider_builder;
```

## render\mesh_builder.rs

```rust
// src/render/mesh_builder.rs
use bevy::prelude::*;
use bevy::render::mesh::{Indices, PrimitiveTopology};
use bevy::render::render_asset::RenderAssetUsages;

use crate::voxel::grid::VoxelGrid;
use crate::voxel::mesher::VOXEL_SIZE;

/// Строим "кубический" меш из вокселей.
/// - центрируем вокруг (0,0,0);
/// - рисуем только внешние грани (neighbor culling);
/// - нормали смотрят НАРУЖУ.
pub fn build_bevy_mesh(grid: &VoxelGrid) -> Mesh {
    let size = grid.size;

    let extent = Vec3::new(
        size.x as f32 * VOXEL_SIZE,
        size.y as f32 * VOXEL_SIZE,
        size.z as f32 * VOXEL_SIZE,
    );
    let center = extent * 0.5;

    let mut positions: Vec<[f32; 3]> = Vec::new();
    let mut normals:   Vec<[f32; 3]> = Vec::new();
    let mut uvs:       Vec<[f32; 2]> = Vec::new();
    let mut indices:   Vec<u32>      = Vec::new();

    // Хелпер: добавляет одну квадратную грань (2 треугольника).
    // ВЕРШИНЫ в порядке CCW (если смотреть С НАРУЖИ на грань).
    let mut push_face = |verts: [Vec3; 4], normal: Vec3| {
        let base = positions.len() as u32;

        for v in verts {
            let p = v - center; // центрируем вокруг (0,0,0)
            positions.push(p.to_array());
            normals.push(normal.to_array());
            uvs.push([0.0, 0.0]);
        }

        indices.extend_from_slice(&[
            base,     base + 1, base + 2,
            base,     base + 2, base + 3,
        ]);
    };

    // Сосед пустой, если:
    // - вне границ грида
    // - или воксель = 0
    let is_empty = |x: i32, y: i32, z: i32| -> bool {
        if x < 0 || y < 0 || z < 0 ||
           x >= size.x as i32 ||
           y >= size.y as i32 ||
           z >= size.z as i32
        {
            return true;
        }
        grid.get(x as u32, y as u32, z as u32) == 0
    };

    for x in 0..size.x {
        for y in 0..size.y {
            for z in 0..size.z {
                if grid.get(x, y, z) == 0 {
                    continue;
                }

                let fx = x as f32 * VOXEL_SIZE;
                let fy = y as f32 * VOXEL_SIZE;
                let fz = z as f32 * VOXEL_SIZE;

                let min = Vec3::new(fx, fy, fz);
                let max = min + Vec3::splat(VOXEL_SIZE);

                let ix = x as i32;
                let iy = y as i32;
                let iz = z as i32;

                // +X
                if is_empty(ix + 1, iy, iz) {
                    push_face(
                        [
                            Vec3::new(max.x, min.y, min.z),
                            Vec3::new(max.x, max.y, min.z),
                            Vec3::new(max.x, max.y, max.z),
                            Vec3::new(max.x, min.y, max.z),
                        ],
                        Vec3::X,
                    );
                }

                // -X
                if is_empty(ix - 1, iy, iz) {
                    push_face(
                        [
                            Vec3::new(min.x, min.y, max.z),
                            Vec3::new(min.x, max.y, max.z),
                            Vec3::new(min.x, max.y, min.z),
                            Vec3::new(min.x, min.y, min.z),
                        ],
                        -Vec3::X,
                    );
                }

                // +Y (верх) — нормаль вверх, вершины CCW при взгляде сверху
                if is_empty(ix, iy + 1, iz) {
                    push_face(
                        [
                            // v0: min x, max z
                            Vec3::new(min.x, max.y, max.z),
                            // v1: max x, max z
                            Vec3::new(max.x, max.y, max.z),
                            // v2: max x, min z
                            Vec3::new(max.x, max.y, min.z),
                            // v3: min x, min z
                            Vec3::new(min.x, max.y, min.z),
                        ],
                        Vec3::Y,
                    );
                }

                // -Y (низ) — нормаль вниз, вершины CCW при взгляде снизу
                if is_empty(ix, iy - 1, iz) {
                    push_face(
                        [
                            // v0: min x, min z
                            Vec3::new(min.x, min.y, min.z),
                            // v1: max x, min z
                            Vec3::new(max.x, min.y, min.z),
                            // v2: max x, max z
                            Vec3::new(max.x, min.y, max.z),
                            // v3: min x, max z
                            Vec3::new(min.x, min.y, max.z),
                        ],
                        -Vec3::Y,
                    );
                }

                // +Z (передняя грань) — нормаль вперёд (+Z)
                if is_empty(ix, iy, iz + 1) {
                    push_face(
                        [
                            // v0: min x, min y
                            Vec3::new(min.x, min.y, max.z),
                            // v1: max x, min y
                            Vec3::new(max.x, min.y, max.z),
                            // v2: max x, max y
                            Vec3::new(max.x, max.y, max.z),
                            // v3: min x, max y
                            Vec3::new(min.x, max.y, max.z),
                        ],
                        Vec3::Z,
                    );
                }

                // -Z (задняя грань) — нормаль назад (-Z)
                if is_empty(ix, iy, iz - 1) {
                    push_face(
                        [
                            // v0: max x, min y
                            Vec3::new(max.x, min.y, min.z),
                            // v1: min x, min y
                            Vec3::new(min.x, min.y, min.z),
                            // v2: min x, max y
                            Vec3::new(min.x, max.y, min.z),
                            // v3: max x, max y
                            Vec3::new(max.x, max.y, min.z),
                        ],
                        -Vec3::Z,
                    );
                }

            }
        }
    }

    let mut mesh = Mesh::new(PrimitiveTopology::TriangleList, RenderAssetUsages::default());
    mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, positions);
    mesh.insert_attribute(Mesh::ATTRIBUTE_NORMAL, normals);
    mesh.insert_attribute(Mesh::ATTRIBUTE_UV_0, uvs);
    mesh.insert_indices(Indices::U32(indices));

    mesh
}
```

## render\mod.rs

```rust
// src/render/mod.rs
pub mod mesh_builder;
```

## tools\camera_controller.rs

```rust
// src/tools/camera_controller.rs
use bevy::prelude::*;
use bevy::input::mouse::{MouseButton, MouseMotion};

/// Простейшая fly-камера (полёт + вращение мышью).
#[derive(Component)]
pub struct FlyCamera {
    pub yaw: f32,
    pub pitch: f32,
    pub move_speed: f32,
    pub move_speed_fast: f32,
    pub mouse_sensitivity: f32,
}

impl FlyCamera {
    pub fn from_transform(transform: &Transform) -> Self {
        let (yaw, pitch, _roll) = transform.rotation.to_euler(EulerRot::YXZ);
        Self {
            yaw,
            pitch,
            move_speed: 16.0,
            move_speed_fast: 64.0,
            mouse_sensitivity: 0.15,
        }
    }
}

/// Поворот камеры правой кнопкой мыши.
pub fn fly_camera_look(
    time: Res<Time>,
    mut mouse_motion: EventReader<MouseMotion>,
    mouse_buttons: Res<ButtonInput<MouseButton>>,
    mut query: Query<(&mut Transform, &mut FlyCamera)>,
) {
    let (mut transform, mut flycam) = if let Ok(v) = query.get_single_mut() {
        v
    } else {
        // съедаем события, чтобы они не копились
        for _ in mouse_motion.read() {}
        return;
    };

    // крутим только при зажатой ПКМ
    if !mouse_buttons.pressed(MouseButton::Right) {
        for _ in mouse_motion.read() {}
        return;
    }

    let mut delta = Vec2::ZERO;
    for ev in mouse_motion.read() {
        delta += ev.delta;
    }
    if delta == Vec2::ZERO {
        return;
    }

    let dt = time.delta_seconds();
    flycam.yaw   -= delta.x * flycam.mouse_sensitivity * dt;
    flycam.pitch -= delta.y * flycam.mouse_sensitivity * dt;

    // ограничиваем наклон вверх/вниз
    flycam.pitch = flycam.pitch.clamp(-1.5, 1.5);

    transform.rotation =
        Quat::from_axis_angle(Vec3::Y, flycam.yaw) *
        Quat::from_axis_angle(Vec3::X, flycam.pitch);
}

/// Движение: WASD + Space/Ctrl, Shift — ускорение.
pub fn fly_camera_move(
    time: Res<Time>,
    keys: Res<ButtonInput<KeyCode>>,
    mut query: Query<(&mut Transform, &FlyCamera)>,
) {
    let (mut transform, flycam) = if let Ok(v) = query.get_single_mut() {
        v
    } else {
        return;
    };

    let mut dir = Vec3::ZERO;

    // вперёд/назад по направлению камеры
    if keys.pressed(KeyCode::KeyW) {
        dir += *transform.forward();
    }
    if keys.pressed(KeyCode::KeyS) {
        dir -= *transform.forward();
    }

    // влево/вправо
    if keys.pressed(KeyCode::KeyA) {
        dir -= *transform.right();
    }
    if keys.pressed(KeyCode::KeyD) {
        dir += *transform.right();
    }

    // вверх/вниз
    if keys.pressed(KeyCode::Space) {
        dir += Vec3::Y;
    }
    if keys.pressed(KeyCode::ControlLeft) {
        dir -= Vec3::Y;
    }

    if dir.length_squared() == 0.0 {
        return;
    }

    dir = dir.normalize();
    let mut speed = flycam.move_speed;
    if keys.pressed(KeyCode::ShiftLeft) {
        speed = flycam.move_speed_fast;
    }

    transform.translation += dir * speed * time.delta_seconds();
}
```

## tools\debug_grid.rs

```rust
// src/tools/debug_grid.rs
use bevy::prelude::*;
use bevy::input::ButtonInput;
use bevy::input::keyboard::KeyCode;

/// Параметры сетки для MVP0-lab.
///
/// По смыслу:
/// - каждые 32 юнита — страйд Octochunk
/// - 64 — Chunk
/// - 256 — Region (у нас extent = 256, так что это граница "пола")
pub const GRID_EXTENT: f32 = 256.0;
pub const GRID_MINOR_STEP: f32 = 1.0;
pub const GRID_OCTOCHUNK_STEP: f32 = 32.0;
pub const GRID_CHUNK_STEP: f32 = 64.0;
pub const GRID_REGION_STEP: f32 = 256.0;

/// Паттерн пунктира для Octochunk-линий:
/// 2 полных клетки → 1 пустая → 1 "точка" → 1 пустая → повтор.
const PATTERN_LEN: i32 = 5;
const DOT_FRACTION: f32 = 0.45; // доля клетки, занимаемая "точкой"

/// Половина длины перекрестия (крестика) на пересечениях Octochunk-сетки.
const OCTO_CROSS_HALF: f32 = 3.0;

#[derive(Copy, Clone, Eq, PartialEq)]
enum GridLineKind {
    Region,
    Chunk,
    Octochunk,
    Minor,
}

/// Состояние оверлея сетки.
/// По умолчанию:
/// - включена только мелкая сетка (воксельная)
/// - Chunk / Octochunk / кресты выключены
pub struct GridOverlayState {
    /// Показывать мелкую сетку (1.0)
    pub show_minor: bool,

    /// Показывать линии Octochunk (32×32, пунктир)
    pub show_octochunk: bool,

    /// Показывать границы Chunk (64×64, сплошные)
    pub show_chunk: bool,

    /// Показывать крестики в узлах Octochunk (перекрёстки 32×32)
    pub show_octochunk_crosses: bool,
}

impl Default for GridOverlayState {
    fn default() -> Self {
        Self {
            show_minor: true,          // воксельная сетка включена
            show_octochunk: false,     // крупные уровни выключены
            show_chunk: false,
            show_octochunk_crosses: false,
        }
    }
}

/// Определяем, к какому уровню топологии относится линия по координате.
fn classify_line(coord: f32) -> GridLineKind {
    let c = coord.round();

    if (c % GRID_REGION_STEP).abs() < 0.001 {
        GridLineKind::Region
    } else if (c % GRID_CHUNK_STEP).abs() < 0.001 {
        GridLineKind::Chunk
    } else if (c % GRID_OCTOCHUNK_STEP).abs() < 0.001 {
        GridLineKind::Octochunk
    } else {
        GridLineKind::Minor
    }
}

/// Цвет для каждого типа линий.
fn color_for_line(kind: GridLineKind) -> Color {
    match kind {
        GridLineKind::Region    => Color::rgba(1.0, 0.3, 0.3, 0.9),   // красный "маяк"
        GridLineKind::Chunk     => Color::rgba(0.95, 0.95, 0.95, 0.9),// почти белый, сплошной
        GridLineKind::Octochunk => Color::rgba(0.9, 0.9, 0.9, 0.8),   // белый пунктир
        GridLineKind::Minor     => Color::rgba(0.45, 0.45, 0.45, 0.25),// тусклая "пыль"
    }
}

/// Основная система отрисовки сетки.
pub fn debug_grid_system(
    mut gizmos: Gizmos,
    camera_q: Query<&Transform, With<Camera3d>>,
    keyboard: Res<ButtonInput<KeyCode>>,
    mut state: Local<GridOverlayState>,
) {
    // F3 — переключаем режим:
    // OFF: только воксельная сетка (minor)
    // ON:  Chunk + Octochunk + кресты + (minor остаётся)
    if keyboard.just_pressed(KeyCode::F3) {
        let enable = !state.show_octochunk;
        state.show_octochunk = enable;
        state.show_chunk = enable;
        state.show_octochunk_crosses = enable;
        // мелкую сетку не трогаем — она всегда включена по state.show_minor
    }

    let y = 0.0;
    let extent = GRID_EXTENT;

    // Положение камеры по высоте — используем как простую метрику "насколько близко".
    // Это LOD: даже если режим включен, слишком высоко мелкие детали не рисуем.
    let cam_y = camera_q
        .get_single()
        .map(|t| t.translation.y.abs())
        .unwrap_or(64.0);

    let lod_octochunk = cam_y < 200.0;
    let lod_minor     = cam_y < 80.0;

    // Фактические флаги отрисовки с учётом LOD и состояния.
    let draw_minor     = lod_minor && state.show_minor;
    let draw_octochunk = lod_octochunk && state.show_octochunk;
    let draw_chunk     = state.show_chunk; // при желании сюда тоже можно прикрутить LOD

    // Оси X (красная) и Z (синяя) — для ориентира
    gizmos.line(
        Vec3::new(-extent, y, 0.0),
        Vec3::new( extent, y, 0.0),
        Color::RED,
    );
    gizmos.line(
        Vec3::new(0.0, y, -extent),
        Vec3::new(0.0, y,  extent),
        Color::BLUE,
    );

    // Линии, параллельные оси Z (x меняется)
    let mut x = -extent;
    while x <= extent {
        let kind = classify_line(x);

        match kind {
            GridLineKind::Minor if !draw_minor => {
                x += GRID_MINOR_STEP;
                continue;
            }
            GridLineKind::Octochunk if !draw_octochunk => {
                x += GRID_MINOR_STEP;
                continue;
            }
            GridLineKind::Chunk if !draw_chunk => {
                x += GRID_MINOR_STEP;
                continue;
            }
            _ => {}
        }

        let color = color_for_line(kind);

        match kind {
            GridLineKind::Octochunk => {
                // Для Octochunk-линий рисуем пунктир вдоль Z
                draw_octochunk_dotted_line_z(&mut gizmos, x, y, extent, color);
            }
            _ => {
                // Остальные — сплошные
                gizmos.line(
                    Vec3::new(x, y, -extent),
                    Vec3::new(x, y,  extent),
                    color,
                );
            }
        }

        x += GRID_MINOR_STEP;
    }

    // Линии, параллельные оси X (z меняется)
    let mut z = -extent;
    while z <= extent {
        let kind = classify_line(z);

        match kind {
            GridLineKind::Minor if !draw_minor => {
                z += GRID_MINOR_STEP;
                continue;
            }
            GridLineKind::Octochunk if !draw_octochunk => {
                z += GRID_MINOR_STEP;
                continue;
            }
            GridLineKind::Chunk if !draw_chunk => {
                z += GRID_MINOR_STEP;
                continue;
            }
            _ => {}
        }

        let color = color_for_line(kind);

        match kind {
            GridLineKind::Octochunk => {
                // Для Octochunk-линий рисуем пунктир вдоль X
                draw_octochunk_dotted_line_x(&mut gizmos, z, y, extent, color);
            }
            _ => {
                gizmos.line(
                    Vec3::new(-extent, y, z),
                    Vec3::new( extent, y, z),
                    color,
                );
            }
        }

        z += GRID_MINOR_STEP;
    }

    // Крестики в пересечениях Octochunk-сетки (между 4 Octochunk'ами).
    if draw_octochunk && state.show_octochunk_crosses {
        draw_octochunk_crosses(&mut gizmos, y, extent);
    }
}

/// Пунктир вдоль оси Z при фиксированном X.
/// Паттерн: 2 клетки линия → 1 пустая → 1 "точка" → 1 пустая.
fn draw_octochunk_dotted_line_z(
    gizmos: &mut Gizmos,
    x: f32,
    y: f32,
    extent: f32,
    color: Color,
) {
    let step = GRID_MINOR_STEP;

    let mut z = -extent;
    let mut cell_index: i32 = 0;

    while z < extent {
        let next_z = (z + step).min(extent);
        let pattern = cell_index.rem_euclid(PATTERN_LEN);

        match pattern {
            // 2 полные клетки
            0 | 1 => {
                gizmos.line(
                    Vec3::new(x, y, z),
                    Vec3::new(x, y, next_z),
                    color,
                );
            }
            // пустые клетки — ничего не рисуем
            2 | 4 => { /* gap */ }
            // "точка" — короткий сегмент по центру клетки
            3 => {
                let mid = (z + next_z) * 0.5;
                let half_len = (next_z - z) * DOT_FRACTION * 0.5;
                gizmos.line(
                    Vec3::new(x, y, mid - half_len),
                    Vec3::new(x, y, mid + half_len),
                    color,
                );
            }
            _ => {}
        }

        z = next_z;
        cell_index += 1;
    }
}

/// Пунктир вдоль оси X при фиксированном Z.
/// Тот же паттерн, но по X.
fn draw_octochunk_dotted_line_x(
    gizmos: &mut Gizmos,
    z: f32,
    y: f32,
    extent: f32,
    color: Color,
) {
    let step = GRID_MINOR_STEP;

    let mut x = -extent;
    let mut cell_index: i32 = 0;

    while x < extent {
        let next_x = (x + step).min(extent);
        let pattern = cell_index.rem_euclid(PATTERN_LEN);

        match pattern {
            0 | 1 => {
                gizmos.line(
                    Vec3::new(x,      y, z),
                    Vec3::new(next_x, y, z),
                    color,
                );
            }
            2 | 4 => { /* gap */ }
            3 => {
                let mid = (x + next_x) * 0.5;
                let half_len = (next_x - x) * DOT_FRACTION * 0.5;
                gizmos.line(
                    Vec3::new(mid - half_len, y, z),
                    Vec3::new(mid + half_len, y, z),
                    color,
                );
            }
            _ => {}
        }

        x = next_x;
        cell_index += 1;
    }
}

/// Рисуем крестики в узлах Octochunk-сетки:
/// в каждой точке (k*32, m*32) — небольшой крест.
fn draw_octochunk_crosses(
    gizmos: &mut Gizmos,
    y: f32,
    extent: f32,
) {
    let max_index = (extent / GRID_OCTOCHUNK_STEP).floor() as i32;
    let color = color_for_line(GridLineKind::Octochunk);

    for ix in -max_index..=max_index {
        let x = ix as f32 * GRID_OCTOCHUNK_STEP;

        for iz in -max_index..=max_index {
            let z = iz as f32 * GRID_OCTOCHUNK_STEP;

            // Горизонтальная часть креста
            gizmos.line(
                Vec3::new(x - OCTO_CROSS_HALF, y, z),
                Vec3::new(x + OCTO_CROSS_HALF, y, z),
                color,
            );

            // Вертикальная часть креста
            gizmos.line(
                Vec3::new(x, y, z - OCTO_CROSS_HALF),
                Vec3::new(x, y, z + OCTO_CROSS_HALF),
                color,
            );
        }
    }
}
```

## tools\egui_panel.rs

```rust
```

## tools\mod.rs

```rust
// src/tools/mod.rs

pub mod debug_grid;
pub mod egui_panel;
pub mod camera_controller;
```

## voxel\grid.rs

```rust
// src/voxel/grid.rs
use bevy::prelude::*;

/// Размер грида по одной оси по умолчанию (можно менять при создании)
pub const VOXELS_PER_AXIS: u32 = 32;

/// Простейший воксельный грид: size и плоский массив данных.
/// 0 = пусто, >0 = какой-то материал.
pub struct VoxelGrid {
    pub size: UVec3,
    pub data: Vec<u8>,
}

impl VoxelGrid {
    /// Создаёт грид указанного размера и заполняет нулями.
    pub fn new(size: UVec3) -> Self {
        let len = (size.x * size.y * size.z) as usize;
        Self {
            size,
            data: vec![0; len],
        }
    }

    /// DUN-грид по умолчанию: 32×32×32.
    pub fn new_default() -> Self {
        let size = UVec3::splat(VOXELS_PER_AXIS);
        Self::new(size)
    }

    #[inline]
    fn index(&self, x: u32, y: u32, z: u32) -> Option<usize> {
        if x >= self.size.x || y >= self.size.y || z >= self.size.z {
            return None;
        }
        // порядок как у тебя был: x + X * (y + Y * z)
        let idx = x + self.size.x * (y + self.size.y * z);
        Some(idx as usize)
    }

    #[inline]
    pub fn get(&self, x: u32, y: u32, z: u32) -> u8 {
        if let Some(i) = self.index(x, y, z) {
            self.data[i]
        } else {
            0
        }
    }

    #[inline]
    pub fn set(&mut self, x: u32, y: u32, z: u32, value: u8) {
        if let Some(i) = self.index(x, y, z) {
            self.data[i] = value;
        }
    }

    /// Заполнить весь объём одним значением.
    pub fn fill(&mut self, value: u8) {
        self.data.fill(value);
    }
}
```

## voxel\mesher.rs

```rust
// src/voxel/mesher.rs
use bevy::prelude::*;
use bevy::render::mesh::{Indices, PrimitiveTopology};
use bevy::render::render_asset::RenderAssetUsages;

use crate::voxel::grid::VoxelGrid;

/// Размер одного вокселя в мировых единицах.
pub const VOXEL_SIZE: f32 = 1.0;

/// Направления для 6 граней куба в индексном пространстве грида.
const FACE_OFFSETS: [IVec3; 6] = [
    IVec3::new(0,  1,  0), // +Y (top)
    IVec3::new(0, -1,  0), // -Y (bottom)
    IVec3::new(0,  0,  1), // +Z (front)
    IVec3::new(0,  0, -1), // -Z (back)
    IVec3::new(-1, 0,  0), // -X (left)
    IVec3::new(1,  0,  0), // +X (right)
];

/// Нормали для граней (по тем же индексам).
const FACE_NORMALS: [[f32; 3]; 6] = [
    [0.0,  1.0,  0.0], // +Y
    [0.0, -1.0,  0.0], // -Y
    [0.0,  0.0,  1.0], // +Z
    [0.0,  0.0, -1.0], // -Z
    [-1.0, 0.0,  0.0], // -X
    [1.0,  0.0,  0.0], // +X
];

/// Одинаковые UV для всех граней.
const FACE_UVS: [[f32; 2]; 4] = [
    [0.0, 0.0],
    [1.0, 0.0],
    [1.0, 1.0],
    [0.0, 1.0],
];

/// Строим меш по воксельной решётке:
/// для каждого заполненного вокселя добавляем только те грани,
/// где сосед пустой или вне границ грида.
pub fn build_mesh(grid: &VoxelGrid) -> Mesh {
    let mut positions: Vec<[f32; 3]> = Vec::new();
    let mut normals:   Vec<[f32; 3]> = Vec::new();
    let mut uvs:       Vec<[f32; 2]> = Vec::new();
    let mut indices:   Vec<u32>      = Vec::new();

    let size = grid.size;

    for z in 0..size.z {
        for y in 0..size.y {
            for x in 0..size.x {
                if grid.get(x, y, z) == 0 {
                    continue;
                }

                // Центр вокселя в локальных координатах
                let cx = x as f32 + 0.5;
                let cy = y as f32 + 0.5;
                let cz = z as f32 + 0.5;

                let half = VOXEL_SIZE * 0.5;

                let px = cx + half;
                let nx = cx - half;
                let py = cy + half;
                let ny = cy - half;
                let pz = cz + half;
                let nz = cz - half;

                // Для каждой из 6 граней проверяем соседа
                for face in 0..6 {
                    let offset = FACE_OFFSETS[face];
                    let nx_i = x as i32 + offset.x;
                    let ny_i = y as i32 + offset.y;
                    let nz_i = z as i32 + offset.z;

                    let neighbor_empty = if nx_i < 0
                        || ny_i < 0
                        || nz_i < 0
                        || nx_i >= size.x as i32
                        || ny_i >= size.y as i32
                        || nz_i >= size.z as i32
                    {
                        // Вышли за границы грида — считаем, что там пусто
                        true
                    } else {
                        // Внутри грида — проверяем воксель
                        grid.get(nx_i as u32, ny_i as u32, nz_i as u32) == 0
                    };

                    if neighbor_empty {
                        add_face(
                            face,
                            nx, px, ny, py, nz, pz,
                            &mut positions,
                            &mut normals,
                            &mut uvs,
                            &mut indices,
                        );
                    }
                }
            }
        }
    }

    let mut mesh = Mesh::new(
        PrimitiveTopology::TriangleList,
        RenderAssetUsages::default(),
    );

    mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, positions);
    mesh.insert_attribute(Mesh::ATTRIBUTE_NORMAL, normals);
    mesh.insert_attribute(Mesh::ATTRIBUTE_UV_0, uvs);
    mesh.insert_indices(Indices::U32(indices));

    mesh
}

/// Добавляем одну грань куба в буферы.
/// face: 0..5 — индекс в FACE_OFFSETS / FACE_NORMALS.
fn add_face(
    face: usize,
    nx: f32,
    px: f32,
    ny: f32,
    py: f32,
    nz: f32,
    pz: f32,
    positions: &mut Vec<[f32; 3]>,
    normals: &mut Vec<[f32; 3]>,
    uvs: &mut Vec<[f32; 2]>,
    indices: &mut Vec<u32>,
) {
    let verts: [[f32; 3]; 4] = match face {
        // +Y (top) — нормаль (0, 1, 0)
        0 => [
            [nx, py, pz],
            [px, py, pz],
            [px, py, nz],
            [nx, py, nz],
        ],
        // -Y (bottom) — нормаль (0, -1, 0)
        1 => [
            [nx, ny, nz],
            [px, ny, nz],
            [px, ny, pz],
            [nx, ny, pz],
        ],
        // +Z (front)
        2 => [
            [nx, ny, pz],
            [px, ny, pz],
            [px, py, pz],
            [nx, py, pz],
        ],
        // -Z (back)
        3 => [
            [px, ny, nz],
            [nx, ny, nz],
            [nx, py, nz],
            [px, py, nz],
        ],
        // -X (left)
        4 => [
            [nx, ny, nz],
            [nx, ny, pz],
            [nx, py, pz],
            [nx, py, nz],
        ],
        // +X (right)
        5 => [
            [px, ny, pz],
            [px, ny, nz],
            [px, py, nz],
            [px, py, pz],
        ],
        _ => unreachable!(),
    };

    let normal = FACE_NORMALS[face];

    let start = positions.len() as u32;
    for (i, p) in verts.iter().enumerate() {
        positions.push(*p);
        normals.push(normal);
        uvs.push(FACE_UVS[i]);
    }

    indices.extend_from_slice(&[
        start,
        start + 1,
        start + 2,
        start,
        start + 2,
        start + 3,
    ]);
}
```

## voxel\mod.rs

```rust
// src/voxel/mod.rs
pub mod grid;
pub mod mesher;

pub use grid::{VoxelGrid, VOXELS_PER_AXIS};
```

